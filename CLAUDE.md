# CLAUDE.md - プロジェクト設計ガイドライン

このファイルはClaude Codeが自動的に読み込み、プロジェクト作成時の前提条件として使用します。

---

## 1. プロジェクト構造の標準テンプレート

```
project-name/
├── main.py               # エントリーポイント（ユーザーが最初に実行）
├── [機能名].py           # 単機能モジュール（直接実行可能）
│
├── src/                  # 内部ロジック（直接実行しない）
│   ├── __init__.py
│   └── [モジュール].py
│
├── config/               # 設定ファイル（コードと分離）
│   └── settings.yaml
│
├── tests/                # テストコード
│   └── test_[モジュール].py
│
├── docs/                 # 追加ドキュメント（必要時のみ）
│
├── setup.sh              # セットアップスクリプト
├── requirements.txt      # Python依存関係
├── .gitignore            # Git除外設定
├── README.md             # プロジェクト説明・使い方
└── SETUP.md              # 詳細セットアップ手順
```

---

## 2. 設計原則

### 2.1 関心の分離
- **ルートディレクトリ**: ユーザーが直接実行するファイル
- **src/**: 内部ロジック（インポートして使用）
- **config/**: 設定ファイル（コードから分離）

### 2.2 単一責任の原則
- 1ファイル = 1機能
- ファイル名 = そのファイルの責務を表す
- 例: `separator.py`は分離のみ、`analyzer.py`は分析のみ

### 2.3 設定の外部化
- ハードコードを避け、`config/settings.yaml`に集約
- 環境変数は`${ENV_VAR}`形式で参照

### 2.4 ドキュメント同梱
- README.md: 概要、クイックスタート、使い方
- SETUP.md: 詳細なセットアップ手順
- コード内コメント: Why（なぜ）を書く、What（何）は書かない

---

## 3. ファイル命名規則

| 種類 | 命名規則 | 例 |
|------|----------|-----|
| Pythonモジュール | snake_case | `audio_analyzer.py` |
| クラス | PascalCase | `AudioAnalyzer` |
| 関数・変数 | snake_case | `extract_features()` |
| 定数 | UPPER_SNAKE | `MAX_RETRY_COUNT` |
| 設定ファイル | snake_case | `settings.yaml` |

---

## 4. README.mdの標準構成

```markdown
# プロジェクト名

[1行説明]

## Overview
[プロジェクトの目的と概要]

## Features
- 機能1
- 機能2

## Requirements
- 必要な環境

## Quick Start
[最小手順でのセットアップ]

## Usage
[基本的な使い方]

## Project Structure
[ファイル構造の説明]

## Configuration
[設定方法]

## Troubleshooting
[よくある問題と解決策]

## License
[ライセンス]
```

---

## 5. Git運用ルール

### 5.1 ブランチ戦略
- `main`: 安定版（常に動作する状態）
- `feature/[機能名]`: 機能開発
- `fix/[修正内容]`: バグ修正

### 5.2 コミットメッセージ
```
[タイプ]: [概要]

[詳細説明（任意）]

[関連URL]
```

タイプ:
- `Add`: 新機能追加
- `Fix`: バグ修正
- `Update`: 既存機能の更新
- `Remove`: 機能・ファイル削除
- `Refactor`: リファクタリング
- `Docs`: ドキュメント更新

### 5.3 .gitignore標準内容
```
# Python
__pycache__/
*.py[cod]
venv/
.env

# IDE
.vscode/
.idea/

# OS
.DS_Store
Thumbs.db

# Project specific
*.log
output/
cache/
```

---

## 6. 新規プロジェクト作成チェックリスト

1. [ ] プロジェクトディレクトリ作成
2. [ ] 基本ファイル構造作成（src/, config/）
3. [ ] README.md作成
4. [ ] requirements.txt作成
5. [ ] .gitignore作成
6. [ ] setup.sh作成（必要な場合）
7. [ ] config/settings.yaml作成
8. [ ] main.py（エントリーポイント）作成
9. [ ] 機能モジュール作成
10. [ ] Gitリポジトリ初期化 & 初回コミット

---

## 7. コード品質基準

### 7.1 必須
- 全ての公開関数にdocstring
- 型ヒント使用（Python 3.10+）
- エラーハンドリング（try/except）

### 7.2 推奨
- 関数は50行以内
- ネストは3階層以内
- マジックナンバー禁止（定数化）

---

## 8. プロジェクトタイプ別テンプレート

### 8.1 CLIツール
```
tool-name/
├── main.py           # CLIエントリーポイント（argparse/click）
├── core.py           # コアロジック
├── src/
├── config/
└── ...
```

### 8.2 Webアプリ（Streamlit）
```
app-name/
├── app.py            # Streamlitエントリーポイント
├── pages/            # マルチページ
├── components/       # UIコンポーネント
├── src/              # ビジネスロジック
├── config/
└── ...
```

### 8.3 APIサーバー（FastAPI）
```
api-name/
├── main.py           # FastAPIエントリーポイント
├── routers/          # エンドポイント定義
├── models/           # Pydanticモデル
├── services/         # ビジネスロジック
├── config/
└── ...
```

---

## 9. 依存関係管理

### requirements.txt形式
```
# Core
package-name==1.2.3

# Optional
optional-package==1.0.0  # 説明

# Development
pytest>=7.0.0
```

バージョン指定:
- `==`: 本番環境（厳密固定）
- `>=`: 開発環境（最低バージョン）

---

## 10. このガイドラインの適用

Claude Codeに新規プロジェクト作成を依頼する際:

```
新規プロジェクトを作成してください。
CLAUDE.mdのガイドラインに従って構造化してください。
```

既存プロジェクトの整理を依頼する際:

```
このプロジェクトをCLAUDE.mdのガイドラインに従って
リファクタリングしてください。
```

---

# Claude Code モデル選択ルールブック v2

**主目的**: 最高レベルの開発品質を担保した上で、トークン消費の無駄を排除する
**最終更新**: 2026年2月8日
**対象**: Claude Code CLI 環境
**思想**: Quality First, Then Efficiency（品質が前提、効率は手段）

---

## 0. このドキュメントの根本思想

トークン効率とは「安いモデルを使うこと」ではない。
**同じ品質をより少ないトークンで、より少ない試行回数で達成すること**である。

Opus 4.6 が1回で正確に仕上げるタスクを、Sonnetで2回やり直せば**Sonnetの方が高コスト**になる。
Haikuで3回失敗すれば**Haikuの方が高コスト**になる。

したがって本ドキュメントでは以下の優先順位を絶対遵守する:

```
1. 一発で正確に完了させる（リトライ = 最大の無駄）
2. そのために十分なモデルを選択する
3. その上で Effort Level とモード切替でトークンを削る
```

---

## 11. モデルスペック一覧

| モデル | モデル文字列 | Input / 1M | Output / 1M | 特性 |
|--------|-------------|-----------|-------------|------|
| **Opus 4.6** | `claude-opus-4-6` | $5.00 | $25.00 | 最高知能。エージェント・デバッグ・長期計画。1M Beta対応 |
| **Opus 4.5** | `claude-opus-4-5-20251101` | $5.00 | $25.00 | SWE-bench最高。コード品質・トークン効率が極めて高い |
| **Sonnet 4.5** | `claude-sonnet-4-5-20250929` | $3.00 | $15.00 | バランス型。仕様明確な実装タスクの主力 |
| **Haiku 4.5** | `claude-haiku-4-5-20251001` | $1.00 | $5.00 | 高速・低コスト。コード生成には原則使わない |

**コスト比（Sonnet 4.5 = 1x 基準）**:

| モデル | 倍率 | 1回成功時の実質コスト |
|--------|------|---------------------|
| Opus 4.6 | 1.67x | Sonnet2回失敗+1回成功（= 3x）より安い |
| Sonnet 4.5 | 1x | Haiku3回失敗+Sonnet1回（= 2x）より安い |
| Haiku 4.5 | 0.33x | 失敗率次第でSonnetより高くなる |

> **核心**: Opus 1回完了 vs Sonnet 2回試行 なら、**Opusの方が安い**。
> 最高品質開発において「ケチって下位モデル」は効率化ではなくコスト増。

---

## 12. デフォルト設定

### 推奨デフォルト: OpusPlan

```bash
export ANTHROPIC_MODEL="claude-sonnet-4-5-20250929"
# ただしセッション開始時に即座に:
/model opusplan
```

OpusPlan を基本姿勢とする理由:

- **計画フェーズ**: Opus 4.6 が設計・分析・判断を担当 → 品質の根幹
- **実行フェーズ**: Sonnet 4.5 が実装を担当 → コスト効率
- **自動切替**: 人間が判断する必要がない → 判断ミスによるトークン浪費がゼロ

これにより「どのモデルを使うか」の判断コスト自体を削減する。
OpusPlanから外れる場合のみ、以下のルールで手動切替する。

---

## 13. モデル選択ルール（品質優先フレーム）

### Tier 1: Opus 4.6 単体（OpusPlanではなく固定）

OpusPlanの自動切替すら挟まず、**全フェーズOpus固定**にすべきタスク。

| 指示パターン | 固定にする理由 |
|-------------|--------------|
| 複数ファイルにまたがるバグの根本原因調査 | 実装フェーズでもコードベース横断の推論が継続的に必要 |
| セキュリティ監査・脆弱性分析 | 見落としが致命的。実装（修正）段階でも高精度が不可欠 |
| 本番デプロイ前の最終レビュー | フェーズ切替による品質低下リスクが許容不可 |
| データベースマイグレーション設計+実行 | 実行時のSQL生成ミスが不可逆的損害を招く |
| 複数AIエージェント連携システムの構築 | エージェント間相互作用の実装にもOpus級の精度が必要 |
| MCP サーバーのプロトコル設計+実装 | プロトコル準拠の精度が全体の動作を左右する |
| 認証・認可・暗号化周りの実装 | セキュリティコードの実装ミスは致命的 |

**判断基準**: 「この実装を間違えたら取り返しがつかない」→ Opus 固定

### Tier 2: OpusPlan（デフォルト）

**大半のタスクはここに該当する。** 設計はOpus品質、実装はSonnetコスト。

| 指示パターン | OpusPlanが最適な理由 |
|-------------|-------------------|
| 「新機能を設計して実装して」 | 設計（Opus）→ 実装（Sonnet）に自然に分離する |
| 「このモジュールをリファクタして」 | 影響分析（Opus）→ コード変更（Sonnet） |
| 「API設計+エンドポイント実装」 | スキーマ設計（Opus）→ 実装（Sonnet） |
| 「テスト戦略を立ててテストを書いて」 | 戦略（Opus）→ テストコード（Sonnet） |
| 「パフォーマンス改善」 | ボトルネック分析（Opus）→ 最適化実装（Sonnet） |
| 「CI/CDパイプラインの構築」 | ワークフロー設計（Opus）→ 設定ファイル記述（Sonnet） |
| 「新プロジェクトのスキャフォールド」 | 構成設計（Opus）→ ファイル生成（Sonnet） |
| Demucs統合ツールの機能追加 | 音声処理設計（Opus）→ 統合コード（Sonnet） |
| GitHub + Claude Code自動化ワークフロー | フロー設計（Opus）→ スクリプト実装（Sonnet） |
| Logic Pro連携の新機能 | MIDI/音声処理の設計（Opus）→ 実装（Sonnet） |

### Tier 3: Sonnet 4.5 単体

OpusPlanのオーバーヘッドすら不要な、**仕様が完全に明確な実装タスク**。

| 指示パターン | Sonnet単体で良い理由 |
|-------------|-------------------|
| 「この仕様書通りにコンポーネントを作って」 | 設計判断が不要。仕様→コードの変換 |
| 「このテストケースを書いて」（テスト対象が明確） | パターン化された生成作業 |
| 「既存APIにCRUD操作を追加して」 | 既存パターンの踏襲 |
| 「このCSSをレスポンシブ対応にして」 | フロントエンド実装の定型作業 |
| 「ドキュメント・READMEを書いて」 | 構造化された文章生成 |
| 「Docker / docker-compose の設定」 | テンプレート的な設定生成 |
| 「型定義の追加・修正」 | TypeScript型操作 |
| 「エラーハンドリングの追加」 | パターン化された横断的処理 |
| 「ログ出力の追加」 | 単純な横断的関心事 |

**Sonnet 単体の条件**（すべて該当すること）:
- [ ] 仕様が曖昧さなく明確
- [ ] 設計判断が不要（「何を作るか」が100%確定済み）
- [ ] 既存のコードパターンの延長線上にある
- [ ] 失敗してもリトライ1回で済む確信がある

### Tier 4: Haiku 4.5（厳格に限定）

**最高品質開発においてHaikuの出番は極めて限定的である。**
以下の条件を**すべて満たす**場合のみ使用する。

| 条件 | 説明 |
|------|------|
| コード生成を伴わない | Haikuのコード生成品質は開発基準を満たさない場合がある |
| 推論が一切不要 | 機械的な操作のみ |
| 影響範囲が1行〜数行 | 波及的な問題が起きえない |
| 失敗しても即座に気づける | 結果の正誤が一目で判断可能 |

**Haiku許可タスク（ホワイトリスト方式）**:

| タスク | 具体例 |
|--------|--------|
| 単純なリネーム | 変数名・ファイル名の変更 |
| typo / スペル修正 | 明らかな誤字の修正 |
| 設定値の変更 | `.env`の値変更、`package.json`のバージョン更新 |
| 構文の質問 | 「この書き方の意味は？」 |
| フォーマット整形 | JSON / YAML の整形 |
| `.gitignore` 更新 | パターン追加 |

**Haiku禁止タスク（たとえ簡単に見えても）**:
- 「ロジックを含むコードの生成・修正」は禁止
- 「テストコードの記述」は禁止
- 「複数ファイルにまたがる変更」は禁止
- 「エラーメッセージの分析と対応策の提案」は禁止
- 「簡単なスクリプト」の作成（10行でもロジックがあればSonnet）は禁止

---

## 14. Effort Level 戦略（トークン効率の本丸）

Opus 4.6 の Effort Level は**品質を維持したままトークンを削る最大の武器**である。
モデルを下げるのではなく、**Opusのまま思考深度を調整する**。

### Effort Level 定義

| Level | 思考量 | トークン消費 | 品質 |
|-------|--------|------------|------|
| **high** | 最大 | 多い | 最高 |
| **medium** | 適度 | **highの約24%**（76%削減） | Sonnet 4.5相当 |
| **low** | 最小 | 最少 | 単純タスクなら十分 |

### 核心ルール: Opus medium > Sonnet high

Anthropic の公式データ:

> **Opus 4.5 を medium effort で使用すると、Sonnet 4.5 と同等品質で76%少ないトークン**

これの意味:
- Opus medium のトークン消費 ≒ Opus high の **24%**
- Opus medium のコスト ≒ **Opus価格 × 0.24 ≒ Sonnet価格 × 0.4**
- つまり **Opus medium は Sonnet より安くなる場合がある**

### Effort Level 選択マトリクス

| タスク特性 | Effort | 理由 |
|-----------|--------|------|
| システムアーキテクチャ設計 | **high** | 最大の推論深度が必要 |
| 複雑なバグの根本原因分析 | **high** | 仮説の網羅的検証が必要 |
| セキュリティレビュー | **high** | 見落としが許されない |
| 新機能の設計判断 | **high** | トレードオフの深い分析が必要 |
| 標準的な機能実装 | **medium** | Sonnet相当品質で十分、Opusの確実性で保険 |
| コードレビュー（通常規模） | **medium** | パターン認識中心の作業 |
| リファクタリングの実行 | **medium** | 計画済みの変更の適用 |
| 設定の確認・質問への回答 | **low** | 事実検索レベル |
| 単純なファイル操作指示 | **low** | 推論不要 |

### 実践的なEffort切替パターン

```
# セッション内でのフロー例

/model opus          # Opus固定で開始
# → high effort（デフォルト）でアーキテクチャ設計

# 設計完了後、実装フェーズへ
# → effort を medium に下げて実装開始
# （Sonnetに切り替えるのではなく、Opus mediumで実装）

# 簡単な確認事項
# → effort を low に下げて質問
# （Haikuに切り替えるのではなく、Opus lowで回答）
```

**このアプローチの利点**:
- モデル切替のコンテキストロスがゼロ
- Opusの「指示理解力」が全フェーズで維持される
- Effortを下げても、Opusの基礎能力はSonnet/Haiku以上

---

## 15. 判断フローチャート

```
タスクを受領
  │
  ├─ 実装ミスが不可逆的損害を招く？
  │   └─ YES → Opus 4.6 固定 / high effort
  │
  ├─ 設計判断を含む？
  │   ├─ YES + 実装も含む → OpusPlan（デフォルト）
  │   └─ YES + 設計のみ → Opus 4.6 / high effort
  │
  ├─ 仕様が完全に明確な実装のみ？
  │   ├─ ロジックあり → Sonnet 4.5
  │   └─ ロジックなし + 数行以内 → Haiku 4.5
  │
  ├─ 継続中のOpusセッション内の軽いタスク？
  │   └─ YES → Opus のまま effort を low/medium に下げる
  │         （モデル切替よりコンテキスト維持を優先）
  │
  └─ 判断に迷う → OpusPlan（安全策かつ効率的）
```

---

## 16. トークン効率を最大化する運用ルール

### ルール1: セッション内のモデル切替は最小限にする

モデルを切り替えるとコンテキストが途切れ、再説明のトークンが発生する。
**Effort Level の調整で対応できるならモデルは切り替えない。**

```
悪い例: Opus → Haiku → Opus → Sonnet（切替コスト大）
良い例: Opus high → Opus medium → Opus low → Opus high（コンテキスト維持）
```

### ルール2: プロンプトの精度がモデル選択より重要

曖昧な指示を Opus に投げるより、明確な指示を Sonnet に投げる方が品質が高い。

```
悪い例: 「なんかいい感じにリファクタして」→ Opus（曖昧 → 無駄な推論トークン大量消費）
良い例: 「関数Xを純粋関数に変換し、副作用をモジュールYに集約して」→ Sonnet（明確 → 1回で完了）
```

### ルール3: プロンプトキャッシングを意識した作業順序

同一コンテキストでの連続作業はキャッシュヒット率が上がる。

```
良い例: 同じモジュールの修正 → テスト → ドキュメントを連続で実行
悪い例: モジュールA修正 → モジュールB修正 → モジュールAテスト（コンテキスト切替大）
```

### ルール4: 1Mコンテキストの使用判断

200Kを超えるとプレミアム料金が発生する。以下の場合のみ使用する:

- 巨大なコードベース全体の分析が一度に必要
- 複数の長大なドキュメントを同時参照する必要がある
- 通常コンテキストで分割すると品質が著しく低下する場合

```
/model opus[1m]    # 本当に必要な時だけ
```

### ルール5: Batch API の活用（非リアルタイム作業）

テスト生成、ドキュメント生成、コード整形など即時性が不要な大量処理:

| 通常 | Batch（50%割引） |
|------|----------------|
| Opus: $5/$25 | $2.50/$12.50 |
| Sonnet: $3/$15 | $1.50/$7.50 |

---

## 17. アンチパターン

| アンチパターン | なぜ問題か | 正しい行動 |
|--------------|----------|-----------|
| 「念のためOpus high」を全タスクに | 簡単なタスクに不要なthinkingトークンが発生 | Effort Level で調整 |
| 「節約のためHaiku」でコード生成 | 低品質コード → デバッグ → リトライで結局高コスト | Sonnet以上を使用 |
| セッション途中で頻繁にモデル切替 | コンテキスト喪失 → 再説明トークンの浪費 | Effort調整で対応 |
| 曖昧な指示 + 高性能モデル | 推論迷走 → 大量のthinkingトークン消費 | 指示を明確にしてから投げる |
| 1Mコンテキストの常用 | 200K超のプレミアム料金が常時発生 | 必要な時のみ`[1m]`指定 |
| 長いセッションでのdrift | トークン蓄積 → コスト増 + 品質低下 | 区切りの良いところで新セッション |
| Sonnetで「設計もお願い」 | 設計品質がOpus比で劣る → 実装全体に波及 | 設計は必ずOpusに任せる |

---

## 18. クイックリファレンス: 指示パターン → モデル+Effort

| あなたの指示 | モデル | Effort | コマンド |
|-------------|--------|--------|---------|
| 「アーキテクチャを設計して」 | Opus 4.6 | high | `/model opus` |
| 「バグの根本原因を調査して」 | Opus 4.6 | high | `/model opus` |
| 「セキュリティレビューして」 | Opus 4.6 | high | `/model opus` |
| 「DBマイグレーション書いて」 | Opus 4.6 | high | `/model opus` |
| 「認証ロジック実装して」 | Opus 4.6 | high | `/model opus` |
| 「設計して実装して」 | OpusPlan | auto | `/model opusplan` |
| 「新機能を追加して」 | OpusPlan | auto | `/model opusplan` |
| 「リファクタして」（複数ファイル） | OpusPlan | auto | `/model opusplan` |
| 「テスト戦略を立てて書いて」 | OpusPlan | auto | `/model opusplan` |
| 「Demucsの新機能を追加」 | OpusPlan | auto | `/model opusplan` |
| 「この仕様通りに実装して」 | Sonnet 4.5 | — | デフォルト |
| 「テストケースを書いて」 | Sonnet 4.5 | — | デフォルト |
| 「CSS修正して」 | Sonnet 4.5 | — | デフォルト |
| 「README書いて」 | Sonnet 4.5 | — | デフォルト |
| 「Docker設定して」 | Sonnet 4.5 | — | デフォルト |
| 「Opusセッション中の簡単な質問」 | Opus 4.6 | low | 切替不要 |
| 「Opusセッション中の標準実装」 | Opus 4.6 | medium | 切替不要 |
| 「変数リネームして」 | Haiku 4.5 | — | `/model haiku` |
| 「typo直して」 | Haiku 4.5 | — | `/model haiku` |
| 「.env の値変えて」 | Haiku 4.5 | — | `/model haiku` |

---

## 19. Amon のプロジェクト別デフォルト設定

| プロジェクト | デフォルト | 理由 |
|-------------|-----------|------|
| Demucs音声分離+分析ツール | **OpusPlan** | 音声処理アルゴリズム統合に設計品質が直結 |
| Claude Code + GitHub自動化 | **OpusPlan** | ワークフロー設計の質が全自動化の信頼性を決定 |
| Logic Pro統合（新機能開発） | **OpusPlan** | MIDI/音声処理設計 → 実装の2フェーズ |
| Logic Pro統合（既存機能修正） | **Sonnet 4.5** | 既存パターンの延長。仕様明確 |
| フロントエンドUI（新規） | **OpusPlan** | コンポーネント設計 → 実装 |
| フロントエンドUI（修正） | **Sonnet 4.5** | 既存デザインシステムの踏襲 |
| 設定ファイル・CLAUDE.md編集 | **Haiku 4.5** | 機械的な編集。ロジック不要 |

---

## 20. 環境設定

### 起動コマンド

```bash
# 通常の開発セッション（推奨）
claude
# → 起動後すぐに /model opusplan

# 緊急のセキュリティ修正
claude --model claude-opus-4-6

# 仕様明確な実装のみ
claude --model claude-sonnet-4-5-20250929

# 設定ファイルの軽微な修正
claude --model claude-haiku-4-5-20251001
```

### セッション中の切替

```
/model opus        # Opus 4.6 固定（critical tasks）
/model opusplan    # OpusPlan（デフォルト推奨）
/model sonnet      # Sonnet 4.5（仕様明確な実装）
/model haiku       # Haiku 4.5（機械的操作のみ）
/model opus[1m]    # 1Mコンテキスト（必要時のみ）
```

---

*Quality First, Then Efficiency.*
*最高の開発品質は、正しいモデル選択から始まる。*

*2026年2月8日 作成 — Anthropic公式ドキュメント・APIプライシングに基づく*
